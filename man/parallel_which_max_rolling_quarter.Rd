% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/parallel_which_max_rolling_quarter.R
\name{parallel_which_max_rolling_quarter}
\alias{parallel_which_max_rolling_quarter}
\title{Rolling quarter (3-month) maximum index per row (parallel)}
\usage{
parallel_which_max_rolling_quarter(mat, wrap = FALSE, na_rm = FALSE)
}
\arguments{
\item{mat}{Numeric matrix (rows = cells, columns = months). Must have
at least 3 columns.}

\item{wrap}{Logical; if \code{TRUE}, allow wrap-around windows (e.g., Dec–Jan–Feb).
Default \code{FALSE}.}

\item{na_rm}{Logical; if \code{TRUE}, skip windows containing any \code{NA}; if all
windows contain \code{NA}, the result is \code{NA}. If \code{FALSE} (default), the presence
of any \code{NA} in the row yields \code{NA} for that row.}
}
\value{
An integer vector of length \code{nrow(mat)} with \strong{1-based} starting
indices. Row names are preserved from \code{mat} if present.
}
\description{
Returns, for each row, the \strong{starting column index} (1-based) of the
3-consecutive-column window whose \strong{sum is maximum}, using the parallel
C++ routine \code{rcpp_parallel_which_max_rolling_quarter()}.
}
\examples{
m1 <- matrix(1:(12*3), nrow = 3, byrow = TRUE)
idx <- parallel_which_max_rolling_quarter(m1, wrap = FALSE)  # should be 10,10,10
# Reconstruct each row's 3-month group (no wrap):
res <- t(vapply(seq_len(nrow(m1)), function(i) {
  j0 <- idx[i]; if (is.na(j0) || j0 + 2 > ncol(m1)) return(c(NA, NA, NA))
  m1[i, j0:(j0+2)]
}, numeric(3)))
res
#      [,1] [,2] [,3]
# [1,]   10   11   12
# [2,]   22   23   24
# [3,]   34   35   36

}
