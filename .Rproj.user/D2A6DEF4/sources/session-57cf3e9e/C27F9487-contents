library(checkmate)
library(bench)           # if not available, fallback to microbenchmark below
# library(microbenchmark)

# Optional: control threads used by RcppParallel
# Set once per session; adjust to your CPU
# Sys.setenv(RCPP_PARALLEL_NUM_THREADS = parallel::detectCores() - 1L)

rows <- 2e5  # WARNING: this is large; try with 2e5 first if you want a fast dry-run
cols <- 12

# Build the matrix: each row is 1:12, 13:24, 25:36, ... (by row)
m1 <- matrix(1:(cols*rows), nrow = rows, byrow = TRUE)

# --- Three-matrix quarter index (max) ---
# Windows: [1..3], [2..4], ..., [10..12]
idx_three <- parallel_which_max_quarter_idx(
  m1[, 1:10, drop = FALSE],
  m1[, 2:11, drop = FALSE],
  m1[, 3:12, drop = FALSE],
  na_rm = FALSE
)
# idx_three is 1..10 (start positions within the 10-window layout)
# Convert to absolute month index in 1..12 (same here, because windows are within 1..12)
start_three <- idx_three

# Extract each row’s 3-month group using the 3-matrix index (no wrap)
extract_group <- function(mat, start) {
  n <- ncol(mat)
  stopifnot(n >= 3)
  out <- matrix(NA_real_, nrow(mat), 3)
  ok <- !is.na(start) & (start + 2L <= n)
  if (any(ok)) {
    rr <- which(ok)
    # vectorized extract in chunks to limit memory if needed
    out[ok, ] <- cbind(
      mat[ok, start[ok] + 0L, drop = FALSE],
      mat[ok, start[ok] + 1L, drop = FALSE],
      mat[ok, start[ok] + 2L, drop = FALSE]
    )
  }
  out
}

dim(m1)
start_three:(start_three+2)
m1[ , ]
grp_three <- extract_group(m1, start_three)

# --- Rolling quarter index (max) ---
# Single-matrix rolling 3-month windows, no wrap => same windows 1..10
idx_roll <- parallel_which_max_rolling_quarter(m1, wrap = FALSE, na_rm = FALSE)
start_roll <- idx_roll
grp_roll <- extract_group(m1, start_roll)

# --- Correctness checks ---
stopifnot(
  length(start_three) == nrow(m1),
  length(start_roll)  == nrow(m1)
)
identical_idx <- isTRUE(all.equal(start_three, start_roll, tolerance = 0))
identical_grp <- isTRUE(all.equal(grp_three, grp_roll, tolerance = 0))

cat("Indices identical? ", identical_idx, "\n")
cat("3-month groups identical? ", identical_grp, "\n")

bench_one_size <- function(n_rows, n_rep = 3) {
  message(sprintf("Benchmarking with rows = %d ...", n_rows))
  m <- matrix(1:(cols*n_rows), nrow = n_rows, byrow = TRUE)
  
  # Pre-slice inputs for the three-matrix method to include that cost
  m_a <- m[, 1:10, drop = FALSE]
  m_b <- m[, 2:11, drop = FALSE]
  m_c <- m[, 3:12, drop = FALSE]
  
  # Use bench::mark
  bm <- bench::mark(
    three_matrix = {
      parallel_which_max_quarter_idx(m_a, m_b, m_c, na_rm = FALSE)
    },
    rolling_single = {
      parallel_which_max_rolling_quarter(m, wrap = FALSE, na_rm = FALSE)
    },
    iterations = n_rep,
    check = FALSE,
    memory = TRUE,
    gc = TRUE
  )
  print(bm[, c("expression", "min", "median", "itr/sec", "mem_alloc")])
  invisible(bm)
}

# Warm-up
bm_small <- bench_one_size(2e5, n_rep = 5)

# Full scale (comment out if you’re not ready for ~300+ MB memory use and long runtime)
# bm_big <- bench_one_size(1e6, n_rep = 3)